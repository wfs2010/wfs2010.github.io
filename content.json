{"meta":{"title":"汪逢生的blog","subtitle":null,"description":null,"author":"wfs2010","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于与致谢","date":"2019-06-13T12:22:42.000Z","updated":"2019-06-17T13:24:45.772Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"更新历史 2019.06.17:laoding1.0初版 关于本博客写作是我一直以来的习惯，从最初的网易博客、博客大巴、Lofter 最终自己搭建了这个独立博客，最初部署在 Github 和 Coding 两个平台，目前部署在独立的阿里云服务器上。正在写一本《计算机系统导论》的教材，希望能为中文计算机教材做出一些贡献。欢迎心平气和以及有价值的讨论，但任何流露戾气、浅薄、反智的留言均不予回复。 博客主要分为三大类别： 1. 不周山作品集：学习知识就像不周山，永远不会有『周全』的一天，是为活到老，学到老。主要是我写的系列文章以及书的初稿，偏技术，未来可能会集结成书出版 2. 通天塔作品集：工程实践就像通天塔，需要不断添砖加瓦才能越盖越高。技术相关的实践与思考，包括团队建设、数据平台、实战技术、编程语言与移动开发 3. 好望角作品集：好望角是寻找通往『黄金乐土』的海上通道，终年大风大浪，所谓生活，就是要乘风破浪冲向新大陆嘛。偏人文，包括周记、生活方式以及各类我感兴趣的东西。喜欢我的文章，第二欢迎的是留言，第三欢迎的是分享，第四欢迎的是打赏。如果要问第一欢迎的是什么，我的答案是希望你也能开始自己的写作历程，把自己的见闻和思考分享出来，网络上高质量的中文内容，需要大家一起努力。 关于我 上士闻道，勤而行之 —— 《道德经》 感谢你费心来了解我，就叫我『小土刀』吧。90 后，曾居北京、匹兹堡，现居深圳。本科就读于中山大学，研究生就读于卡耐基梅隆大学，因为想制作游戏而学计算机，却在学习过程中探索了各种方向。不是天才或大牛，所学所做都是为了让生活更有趣一些。 『小土刀』这个 ID 最初源于高中和同学传纸条时的一次笔误，就一直沿用了下来，后来用『wdxtub』作为对应的英文 ID，更多相关信息可以参考博客主要分为三大类别： 我接受多看阅读线上杂志的采访，在《三个书评匠·新年礼物》这一期中 关于我的一个知乎问题 - 为什么小土刀能读那么多书写那么多文章 现就职于微众银行 AI 广告团队，专注于高价值产品的长链和长效营销转化，打造可信广告方案。 业余时间也关注教育事业，专注于为广大三四线城市及乡镇地区的图书馆提供围绕书籍和阅读的系统解决方案，用技术的手段促进教育公平 PS: 我们在招人，感兴趣的小伙伴请联系我。 曾就职于 追一科技 和 大疆创新，主要负责数据挖掘、数据平台与机器学习平台的研发工作，偶尔客串实施运维、测试、产品经理、项目经理、售前等角色。读书那会儿也作为独立开发者做过 iOS/Android/WindowsPhone 应用，上过官方推荐，有大约 80 万下载量。 吃技术饭，致力于把技术转化成真正能给用户和社会带来价值的解决方案，熟悉计算机底层技术与架构，开发过高性能高可用分布式的平台。生活简单规律，阅读、思考和写作占据了我大部分的时间，标准吃货，学过几年乐器，喜欢 Soul Music 和各类运动，讨厌人多及嘈杂的地方。技术背景包括： Go / Python / Scala / Java / Javascript Spark / Hive/ MySQL / Redis / Kubernetes /Docker Beego / Akka / Tensorflow / Linux 机器学习 / 数据挖掘 / 数据平台 / 推荐系统 / 计算机视觉 架构设计 / 日志分析 / 用户体验 / 社区维护 注：我的联系方式可以在侧边栏中找到。 致谢写博客挺久了，但对于『写作』，反而是最近两三年才稍微找到了些门道，也给自己定下了一些规矩： 踏实、真诚、写有价值的内容 时时处处有学问，善于观察与思考 不哗众取宠、不标题党、不妄议 用心交朋友 在文章后面加入打赏的功能，更多的是对自己的鞭策。不是说要写那些『骗』赏的文章，而是想要通过自己的文字抛砖引玉，让大家都变得更好些，如果可能的话，再交些天南海北的好朋友。从原来的固定金额到现在的浮动 + 固定，也算是一个实验。 我既不是网红，也不开网店，唯一有点价值的，可能只有这些敲敲打打的文字了。感谢朋友们一直以来的支持。 发布说明为了致敬开源软件发布流程，会以版本号为索引，记录博客本身内容、架构的更新。 V2.0 2019.05.16时隔两年多的更新，这两年因为工作和生活都处于一个摸索和适应期，基本没有太多时间来照顾博客，但各位读者朋友仍然一直给我提各种各样的意见建议，非常感动。经过两年的实践，无论对写作还是博客都有了更深的认识，也就是 2.0 版本的主要改动： 丢掉历史包袱，只保留 CSAPP 系列，全新起航 沿用不周山、通天塔和好望角的设定 写作聚焦与系列化，不再零散写作（具体的系列可以查看不周山、通天塔和好望角的索引页面） 主题升级，采用最新 Next，支持进度预览、书签和本地搜索功能 统一 4399.com 和 4399.com 两个网站，降低维护成本 V1.0 2017.03.26随着博客数量和涉猎范围的迅速增加，原先的旧索引已经难堪重负，自己查找起来都很不方便。1.0 版本是在 Beta 版本的基础上进行的持续打磨改进，主要改动有： 不周山、通天塔和好望角系列完善写作规范 发布原创的博客图标 增加字数统计与阅读时间预估 Beta 2016.11.30经过一年多时间的筹备，终于能在今天发布 wdxtub.com 的首个 Beta 版本，包含三项我非常满意的重大改动！ 确定不周山、通天塔和好望角铁三角分类组合 博客进入版本化时代，无论文章还是板块更新，均会有更新记录，方便大家查阅最新信息 正式采用 署名(BY)-非商业性(NC)-禁止演绎(ND) 协议"},{"title":"categories","date":"2019-06-13T12:22:32.000Z","updated":"2019-06-13T12:22:32.319Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-06-13T12:22:42.000Z","updated":"2019-06-13T12:22:42.842Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-13T12:20:20.000Z","updated":"2019-06-13T12:21:18.963Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"sitemap","date":"2019-06-13T12:22:57.000Z","updated":"2019-06-13T12:22:57.269Z","comments":true,"path":"sitemap/index.html","permalink":"http://yoursite.com/sitemap/index.html","excerpt":"","text":""},{"title":"schedule","date":"2019-06-13T12:22:49.000Z","updated":"2019-06-13T12:22:49.510Z","comments":true,"path":"schedule/index.html","permalink":"http://yoursite.com/schedule/index.html","excerpt":"","text":""}],"posts":[{"title":"山东大学计算机系统原理实验-3(3)","slug":"山东大学计算机系统原理实验-3","date":"2019-06-17T14:13:53.000Z","updated":"2019-06-17T14:21:05.487Z","comments":true,"path":"2019/06/17/山东大学计算机系统原理实验-3/","link":"","permalink":"http://yoursite.com/2019/06/17/山东大学计算机系统原理实验-3/","excerpt":"","text":"山东大学 软件 学院 深入理解操作系统 课程实验报告 学号：2017003012xx 学号: 2017003011xx 学号: 2017003013xx 姓名：xxx 姓名：xxx 姓名：xxx 班级： AI1班 网安17 网安17 实验题目：基于FPGA的边缘检测 实验学时：8学时 实验日期： 20190520 实验目的： 初步掌握vivado工具 硬件环境： 软件环境： Vivado hls 2018.3 Vivadi 2018.3 实验原理： 本次实验我们计划加速的程序基于FPGA的边缘检测算法： 该算法的大致流程及优化策略如下： 大致流程： 结论分析与体会： 在本次实验中，我们通过使用vivado系列软件，我们将我们编写的实现边缘检测的C代码的程序实现与硬件电路的模拟连接与仿真设计，然后经模拟仿真等步骤成功后，再设计对应电路的IP核以及控制单元等等，最终连接FPGA板，将我们设计好的电路图烧录在FPGA板上，之后就可以将我们编写的实现边缘检测的C代码的程序运行在这个实现了针对我们程序而设计的硬件电路的FPGA板上，从而实现部分定制化的效果，最终达到加速程序运行的目的。 在本次实验中，经过本次实验，我们对程序的优化中的一些操作比如循环展开，以及减少循环内部方法调用等等有了更深的认识和理解。还有就是解除了类似于FPGA这样的硬件上的编程设备，提高了我们的动手能力以及对整个程序在运行过程中各个方法的调用以及变量的存储有了更深的理解。 简介及优化策略： 边缘检测计算机视觉领域的一种重要处理方法。主要用于获得数字图像的一阶梯度.其中一种是在图像上任何一点使用sober算子.公式如下 Gx是检测水平边缘的 ； Gy是检测垂直边缘的 。 所以该算子包含两组3x3的矩阵，分别为横向及纵向，将之与图像作平面卷积，即可分别得出横向及纵向的亮度差分近似值。 图像的每一个像素的横向及纵向灰度值通过下式结合，来计算该点灰度的大小： 得到G后进行阈值比较，即将阈值与给定值进行比较，如果梯度G大于给定值，可以认为是边缘点。将该值置为255，否则为0。 具体优化思路： 数组划分:将input和result图像这些数据划分到多个RAM块中以满足并行访问的需求.以及对算子做数组划分.： 对外层每个像素点做循环展开： 对卷积积操作外层做流水线优化： 对卷积积操作内层做循环展开： 实现过程: 一． 首先我们参考网上的例子，实现了将一张图片进行边缘检测，能够正常运行生成边缘检测的图片和生成IP核。 如下图所示： 顶层函数代码及优化如下： #include “image_core.h” void image_core(AXI_STREAM_IN&amp; input, AXI_STREAM_OUT&amp; output, int rows,int cols){ //#pragma HLS INTERFACE s_axilite port=return bundle=CTRL //#pragma HLS INTERFACE s_axilite port=return bundle=CTRL //#pragma HLS INTERFACE s_axilite port=output //#pragma HLS INTERFACE s_axilite port=input #pragma HLS RESOURCE variable=input core=AXI4Stream metadata=”-bus_bundleINPUT_STREAM” #pragma HLS RESOURCE variable=output core=AXI4Stream metadata=”-bus_bundleOUTPUT_STREAM” #pragma HLS INTERFACE ap_none port=cols #pragma HLS INTERFACE ap_none port=rows // #pragma HLS interface ap_ctrl_none port=return RGB_IMAGE img_0(rows, cols); RGB_IMAGE img_1(rows, cols); #pragma HLS DATAFLOW // must use data flow to stream the data hls::AXIvideo2Mat(input, img_0); //读输入到img_0 hls::Sobel&lt;1,0,3&gt;(img_0, img_1); //Sobel算子，边缘提取 hls::Mat2AXIvideo(img_1, output); //img_1写到输出 } 但是我们在连电路的时候没有搞懂输入流应该如何处理，通过询问助教和浏览资料我们发现需要对应IP核的输入流和输出流我们需要用到一些相关的组件，我们使用了axi-dma组件来连接输入输出流，但是由于对组件不熟悉，我们最后摸索连出的电路无法通过模拟 因此选择了第二种方法，将图片看作是一个矩阵，矩阵的值看做图片的灰度值，用对一个简单的矩阵进行边缘检测的卷积运算来代替对图片进行卷积运算。 在VIVADO HLS中书写基本代码，验证正确性 通过验证并可以生成IP核 于是开始考虑对代码进行优化 优化代码中的循环结构 优化思路： 基于HLS硬件化指令的优化： 我们首先使用了hls的硬件化指令进行优化： 优化后 我们想到可以通过重构代码来完成循环展开，于是将卷积乘运算进行了展开，数组直接和算子乘加运算。 通过比较我们发现，在时钟周期相同的情况下，三种方法当中完成所有输出所需的时间逐渐减少，因此我们最终选择了第三种方法。输出IP核。 连接电路 打开vivado 导入我们刚才的IP核，进行电路的连接，这里参考学长学姐给的demo，我们连接完成的图片如图所示： 电路模拟验证成功，打开SDK烧入fpga，实验完成。 实验结果： 我们先将边缘检测算法进行了在vivado模拟仿真以及IP核的设计，但在IP核及其电路的设计时，出现了一些问题，导致电路的检测不通过，最终经过一系列的调试，还是没能实现在FPGA上的烧录及运行，只在vivado软件中实现了大概的图像处理，效果如下图： 在这个算法失败后，因为图片可以看作是一个个像素点的矩阵数组，所以我们采取了一个类似于的边缘检测算法的简化版的随机数矩阵的处理算法，最终实现了在FPGA上的烧录运行以及矩阵处理后结果的输出。 实验代码： Test.cpp #include &lt;core.cpp&gt; void IEE(double gray[N][N],double dst[N][N]); double A[N][N]; double B[N][N]; void init_array() { int i,j; for(i=0;i&lt;N;i++) { for (j = 0; j &lt; N; ++j) { A[i][j] = j%5; B[i][j] = 0; } } } void print_array() { int i,j; for(i=0;i&lt;N;i++) { for (j = 0; j &lt; N; ++j) { } } } int main(){ init_array(); IEE(A, B); print_array(); } Core.h #include “math.h” Core.cpp #include “core.h” #define N 10 //canny algo void IEE(double gray[N][N],double dst[N][N]) { int Gx[3][3]={ {-1,0,1}, {-2,0,2},{-1,0,1}}; int Gy[3][3]={ {-1,-2,-1}, {0,0,0},{1,2,1}}; //#pragma HLS array_partition variable=gray complete dim =1 //#pragma HLS array_partition variable=dst complete dim =1 double gy; double gx; int i,j,a,b,c; for (i = 0; i &lt; N-2; ++i) { #pragma HLS UNROLL for ( j = 0; j &lt; N-2; ++j) { #pragma HLS UNROLL // for (a = 0; a &lt; 3; ++a) { // #pragma HLS PIPELINE // for (b = 0; b &lt; 3; ++b) { // #pragma HLS PIPELINE // for (c = 0; c &lt;3 ; ++c) { // #pragma HLS UNROLL // gx+=gray[i+a][j+c]*Gx[c][b]; // gy+=gray[i+a][j+c]*Gy[c][b]; // } // } // } double gy =gray[i][j]+gray[i][j+1]*2+gray[i][j+2]-gray[i+2][j]-gray[i+2][j+1]*2-gray[i+2][j+2]; double gx =gray[i][j]+gray[i+1][j]*2+gray[i+2][j]-gray[i][j+2]-gray[i+1][j+2]*2-gray[i+2][j+2]; double grad = sqrt(gx*gx+gy*gy); if(grad&gt;51){ dst[i][j] = 255; } else { dst[i][j] = 0; } gx=0; gy=0; } } return; }","categories":[],"tags":[{"name":"深入理解计算机系统","slug":"深入理解计算机系统","permalink":"http://yoursite.com/tags/深入理解计算机系统/"}]},{"title":"hexo 图片","slug":"hexo-图片","date":"2019-06-17T13:47:34.000Z","updated":"2019-06-17T14:06:44.765Z","comments":true,"path":"2019/06/17/hexo-图片/","link":"","permalink":"http://yoursite.com/2019/06/17/hexo-图片/","excerpt":"","text":"把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。 最后检查一下，hexo g生成页面后，进入public\\2017\\02\\26\\index.html文件中查看相关字段，可以发现，html标签内的语句是img src=”2017/02/26/xxxx/图片名.jpg”，而不是img src=”xxxx/图片名.jpg。这很重要，关乎你的网页是否可以真正加载你想插入的图片","categories":[],"tags":[{"name":"git bug","slug":"git-bug","permalink":"http://yoursite.com/tags/git-bug/"}]},{"title":"山东大学计算机系统原理实验(1)","slug":"山东大学计算机系统原理实验-1-1","date":"2019-06-17T13:45:48.000Z","updated":"2019-06-17T14:08:59.466Z","comments":true,"path":"2019/06/17/山东大学计算机系统原理实验-1-1/","link":"","permalink":"http://yoursite.com/2019/06/17/山东大学计算机系统原理实验-1-1/","excerpt":"","text":"山东大学 软件 学院 深入理解操作系统 课程实验报告 学号：2017003012xx 学号: 2017003011xx 学号: 2017003013xx 姓名：xxx 姓名：xxx 姓名：xxx 班级： AI1班 网安17 网安17 实验题目：基于FPGA的边缘检测 实验学时：8学时 实验日期： 20190520 实验目的： 初步掌握vivado工具 硬件环境： 软件环境： Vivado hls 2018.3 Vivadi 2018.3 实验原理： 本次实验我们计划加速的程序基于FPGA的边缘检测算法： 该算法的大致流程及优化策略如下： 大致流程： 结论分析与体会： 在本次实验中，我们通过使用vivado系列软件，我们将我们编写的实现边缘检测的C代码的程序实现与硬件电路的模拟连接与仿真设计，然后经模拟仿真等步骤成功后，再设计对应电路的IP核以及控制单元等等，最终连接FPGA板，将我们设计好的电路图烧录在FPGA板上，之后就可以将我们编写的实现边缘检测的C代码的程序运行在这个实现了针对我们程序而设计的硬件电路的FPGA板上，从而实现部分定制化的效果，最终达到加速程序运行的目的。 在本次实验中，经过本次实验，我们对程序的优化中的一些操作比如循环展开，以及减少循环内部方法调用等等有了更深的认识和理解。还有就是解除了类似于FPGA这样的硬件上的编程设备，提高了我们的动手能力以及对整个程序在运行过程中各个方法的调用以及变量的存储有了更深的理解。 简介及优化策略： 边缘检测计算机视觉领域的一种重要处理方法。主要用于获得数字图像的一阶梯度.其中一种是在图像上任何一点使用sober算子.公式如下 Gx是检测水平边缘的 ； Gy是检测垂直边缘的 。 所以该算子包含两组3x3的矩阵，分别为横向及纵向，将之与图像作平面卷积，即可分别得出横向及纵向的亮度差分近似值。 图像的每一个像素的横向及纵向灰度值通过下式结合，来计算该点灰度的大小： 得到G后进行阈值比较，即将阈值与给定值进行比较，如果梯度G大于给定值，可以认为是边缘点。将该值置为255，否则为0。 具体优化思路： 数组划分:将input和result图像这些数据划分到多个RAM块中以满足并行访问的需求.以及对算子做数组划分.： 对外层每个像素点做循环展开： 对卷积积操作外层做流水线优化： 对卷积积操作内层做循环展开： 实现过程: 一． 首先我们参考网上的例子，实现了将一张图片进行边缘检测，能够正常运行生成边缘检测的图片和生成IP核。 如下图所示： 顶层函数代码及优化如下： #include “image_core.h” void image_core(AXI_STREAM_IN&amp; input, AXI_STREAM_OUT&amp; output, int rows,int cols){ //#pragma HLS INTERFACE s_axilite port=return bundle=CTRL //#pragma HLS INTERFACE s_axilite port=return bundle=CTRL //#pragma HLS INTERFACE s_axilite port=output //#pragma HLS INTERFACE s_axilite port=input #pragma HLS RESOURCE variable=input core=AXI4Stream metadata=”-bus_bundleINPUT_STREAM” #pragma HLS RESOURCE variable=output core=AXI4Stream metadata=”-bus_bundleOUTPUT_STREAM” #pragma HLS INTERFACE ap_none port=cols #pragma HLS INTERFACE ap_none port=rows // #pragma HLS interface ap_ctrl_none port=return RGB_IMAGE img_0(rows, cols); RGB_IMAGE img_1(rows, cols); #pragma HLS DATAFLOW // must use data flow to stream the data hls::AXIvideo2Mat(input, img_0); //读输入到img_0 hls::Sobel&lt;1,0,3&gt;(img_0, img_1); //Sobel算子，边缘提取 hls::Mat2AXIvideo(img_1, output); //img_1写到输出 } 但是我们在连电路的时候没有搞懂输入流应该如何处理，通过询问助教和浏览资料我们发现需要对应IP核的输入流和输出流我们需要用到一些相关的组件，我们使用了axi-dma组件来连接输入输出流，但是由于对组件不熟悉，我们最后摸索连出的电路无法通过模拟 因此选择了第二种方法，将图片看作是一个矩阵，矩阵的值看做图片的灰度值，用对一个简单的矩阵进行边缘检测的卷积运算来代替对图片进行卷积运算。 在VIVADO HLS中书写基本代码，验证正确性 通过验证并可以生成IP核 于是开始考虑对代码进行优化 优化代码中的循环结构 优化思路： 基于HLS硬件化指令的优化： 我们首先使用了hls的硬件化指令进行优化： 优化后 我们想到可以通过重构代码来完成循环展开，于是将卷积乘运算进行了展开，数组直接和算子乘加运算。 通过比较我们发现，在时钟周期相同的情况下，三种方法当中完成所有输出所需的时间逐渐减少，因此我们最终选择了第三种方法。输出IP核。 连接电路 打开vivado 导入我们刚才的IP核，进行电路的连接，这里参考学长学姐给的demo，我们连接完成的图片如图所示： 电路模拟验证成功，打开SDK烧入fpga，实验完成。 实验结果： 我们先将边缘检测算法进行了在vivado模拟仿真以及IP核的设计，但在IP核及其电路的设计时，出现了一些问题，导致电路的检测不通过，最终经过一系列的调试，还是没能实现在FPGA上的烧录及运行，只在vivado软件中实现了大概的图像处理，效果如下图： 在这个算法失败后，因为图片可以看作是一个个像素点的矩阵数组，所以我们采取了一个类似于的边缘检测算法的简化版的随机数矩阵的处理算法，最终实现了在FPGA上的烧录运行以及矩阵处理后结果的输出。 实验代码： Test.cpp #include &lt;core.cpp&gt; void IEE(double gray[N][N],double dst[N][N]); double A[N][N]; double B[N][N]; void init_array() { int i,j; for(i=0;i&lt;N;i++) { for (j = 0; j &lt; N; ++j) { A[i][j] = j%5; B[i][j] = 0; } } } void print_array() { int i,j; for(i=0;i&lt;N;i++) { for (j = 0; j &lt; N; ++j) { } } } int main(){ init_array(); IEE(A, B); print_array(); } Core.h #include “math.h” Core.cpp #include “core.h” #define N 10 //canny algo void IEE(double gray[N][N],double dst[N][N]) { int Gx[3][3]={ {-1,0,1}, {-2,0,2},{-1,0,1}}; int Gy[3][3]={ {-1,-2,-1}, {0,0,0},{1,2,1}}; //#pragma HLS array_partition variable=gray complete dim =1 //#pragma HLS array_partition variable=dst complete dim =1 double gy; double gx; int i,j,a,b,c; for (i = 0; i &lt; N-2; ++i) { #pragma HLS UNROLL for ( j = 0; j &lt; N-2; ++j) { #pragma HLS UNROLL // for (a = 0; a &lt; 3; ++a) { // #pragma HLS PIPELINE // for (b = 0; b &lt; 3; ++b) { // #pragma HLS PIPELINE // for (c = 0; c &lt;3 ; ++c) { // #pragma HLS UNROLL // gx+=gray[i+a][j+c]*Gx[c][b]; // gy+=gray[i+a][j+c]*Gy[c][b]; // } // } // } double gy =gray[i][j]+gray[i][j+1]*2+gray[i][j+2]-gray[i+2][j]-gray[i+2][j+1]*2-gray[i+2][j+2]; double gx =gray[i][j]+gray[i+1][j]*2+gray[i+2][j]-gray[i][j+2]-gray[i+1][j+2]*2-gray[i+2][j+2]; double grad = sqrt(gx*gx+gy*gy); if(grad&gt;51){ dst[i][j] = 255; } else { dst[i][j] = 0; } gx=0; gy=0; } } return; }","categories":[],"tags":[]},{"title":"山东大学计算机系统原理实验(2)","slug":"山东大学计算机系统原理实验-2-1","date":"2019-06-17T13:45:41.000Z","updated":"2019-06-17T13:45:41.709Z","comments":true,"path":"2019/06/17/山东大学计算机系统原理实验-2-1/","link":"","permalink":"http://yoursite.com/2019/06/17/山东大学计算机系统原理实验-2-1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"山东大学计算机系统原理实验(3)","slug":"山东大学计算机系统原理实验-3-1","date":"2019-06-17T13:45:35.000Z","updated":"2019-06-17T14:10:56.123Z","comments":true,"path":"2019/06/17/山东大学计算机系统原理实验-3-1/","link":"","permalink":"http://yoursite.com/2019/06/17/山东大学计算机系统原理实验-3-1/","excerpt":"","text":"山东大学 软件 学院 深入理解操作系统 课程实验报告 学号：2017003012xx 学号: 2017003011xx 学号: 2017003013xx 姓名：xxx 姓名：xxx 姓名：xxx 班级： AI1班 网安17 网安17 实验题目：基于FPGA的边缘检测 实验学时：8学时 实验日期： 20190520 实验目的： 初步掌握vivado工具 硬件环境： 软件环境： Vivado hls 2018.3 Vivadi 2018.3 实验原理： 本次实验我们计划加速的程序基于FPGA的边缘检测算法： 该算法的大致流程及优化策略如下： 大致流程： 结论分析与体会： 在本次实验中，我们通过使用vivado系列软件，我们将我们编写的实现边缘检测的C代码的程序实现与硬件电路的模拟连接与仿真设计，然后经模拟仿真等步骤成功后，再设计对应电路的IP核以及控制单元等等，最终连接FPGA板，将我们设计好的电路图烧录在FPGA板上，之后就可以将我们编写的实现边缘检测的C代码的程序运行在这个实现了针对我们程序而设计的硬件电路的FPGA板上，从而实现部分定制化的效果，最终达到加速程序运行的目的。 在本次实验中，经过本次实验，我们对程序的优化中的一些操作比如循环展开，以及减少循环内部方法调用等等有了更深的认识和理解。还有就是解除了类似于FPGA这样的硬件上的编程设备，提高了我们的动手能力以及对整个程序在运行过程中各个方法的调用以及变量的存储有了更深的理解。 简介及优化策略： 边缘检测计算机视觉领域的一种重要处理方法。主要用于获得数字图像的一阶梯度.其中一种是在图像上任何一点使用sober算子.公式如下 Gx是检测水平边缘的 ； Gy是检测垂直边缘的 。 所以该算子包含两组3x3的矩阵，分别为横向及纵向，将之与图像作平面卷积，即可分别得出横向及纵向的亮度差分近似值。 图像的每一个像素的横向及纵向灰度值通过下式结合，来计算该点灰度的大小： 得到G后进行阈值比较，即将阈值与给定值进行比较，如果梯度G大于给定值，可以认为是边缘点。将该值置为255，否则为0。 具体优化思路： 数组划分:将input和result图像这些数据划分到多个RAM块中以满足并行访问的需求.以及对算子做数组划分.： 对外层每个像素点做循环展开： 对卷积积操作外层做流水线优化： 对卷积积操作内层做循环展开： 实现过程: 一． 首先我们参考网上的例子，实现了将一张图片进行边缘检测，能够正常运行生成边缘检测的图片和生成IP核。 如下图所示： 顶层函数代码及优化如下： #include “image_core.h” void image_core(AXI_STREAM_IN&amp; input, AXI_STREAM_OUT&amp; output, int rows,int cols){ //#pragma HLS INTERFACE s_axilite port=return bundle=CTRL //#pragma HLS INTERFACE s_axilite port=return bundle=CTRL //#pragma HLS INTERFACE s_axilite port=output //#pragma HLS INTERFACE s_axilite port=input #pragma HLS RESOURCE variable=input core=AXI4Stream metadata=”-bus_bundleINPUT_STREAM” #pragma HLS RESOURCE variable=output core=AXI4Stream metadata=”-bus_bundleOUTPUT_STREAM” #pragma HLS INTERFACE ap_none port=cols #pragma HLS INTERFACE ap_none port=rows // #pragma HLS interface ap_ctrl_none port=return RGB_IMAGE img_0(rows, cols); RGB_IMAGE img_1(rows, cols); #pragma HLS DATAFLOW // must use data flow to stream the data hls::AXIvideo2Mat(input, img_0); //读输入到img_0 hls::Sobel&lt;1,0,3&gt;(img_0, img_1); //Sobel算子，边缘提取 hls::Mat2AXIvideo(img_1, output); //img_1写到输出 } 但是我们在连电路的时候没有搞懂输入流应该如何处理，通过询问助教和浏览资料我们发现需要对应IP核的输入流和输出流我们需要用到一些相关的组件，我们使用了axi-dma组件来连接输入输出流，但是由于对组件不熟悉，我们最后摸索连出的电路无法通过模拟 因此选择了第二种方法，将图片看作是一个矩阵，矩阵的值看做图片的灰度值，用对一个简单的矩阵进行边缘检测的卷积运算来代替对图片进行卷积运算。 在VIVADO HLS中书写基本代码，验证正确性 通过验证并可以生成IP核 于是开始考虑对代码进行优化 优化代码中的循环结构 优化思路： 基于HLS硬件化指令的优化： 我们首先使用了hls的硬件化指令进行优化： 优化后 我们想到可以通过重构代码来完成循环展开，于是将卷积乘运算进行了展开，数组直接和算子乘加运算。 通过比较我们发现，在时钟周期相同的情况下，三种方法当中完成所有输出所需的时间逐渐减少，因此我们最终选择了第三种方法。输出IP核。 连接电路 打开vivado 导入我们刚才的IP核，进行电路的连接，这里参考学长学姐给的demo，我们连接完成的图片如图所示： 电路模拟验证成功，打开SDK烧入fpga，实验完成。 实验结果： 我们先将边缘检测算法进行了在vivado模拟仿真以及IP核的设计，但在IP核及其电路的设计时，出现了一些问题，导致电路的检测不通过，最终经过一系列的调试，还是没能实现在FPGA上的烧录及运行，只在vivado软件中实现了大概的图像处理，效果如下图： 在这个算法失败后，因为图片可以看作是一个个像素点的矩阵数组，所以我们采取了一个类似于的边缘检测算法的简化版的随机数矩阵的处理算法，最终实现了在FPGA上的烧录运行以及矩阵处理后结果的输出。 实验代码： Test.cpp #include &lt;core.cpp&gt; void IEE(double gray[N][N],double dst[N][N]); double A[N][N]; double B[N][N]; void init_array() { int i,j; for(i=0;i&lt;N;i++) { for (j = 0; j &lt; N; ++j) { A[i][j] = j%5; B[i][j] = 0; } } } void print_array() { int i,j; for(i=0;i&lt;N;i++) { for (j = 0; j &lt; N; ++j) { } } } int main(){ init_array(); IEE(A, B); print_array(); } Core.h #include “math.h” Core.cpp #include “core.h” #define N 10 //canny algo void IEE(double gray[N][N],double dst[N][N]) { int Gx[3][3]={ {-1,0,1}, {-2,0,2},{-1,0,1}}; int Gy[3][3]={ {-1,-2,-1}, {0,0,0},{1,2,1}}; //#pragma HLS array_partition variable=gray complete dim =1 //#pragma HLS array_partition variable=dst complete dim =1 double gy; double gx; int i,j,a,b,c; for (i = 0; i &lt; N-2; ++i) { #pragma HLS UNROLL for ( j = 0; j &lt; N-2; ++j) { #pragma HLS UNROLL // for (a = 0; a &lt; 3; ++a) { // #pragma HLS PIPELINE // for (b = 0; b &lt; 3; ++b) { // #pragma HLS PIPELINE // for (c = 0; c &lt;3 ; ++c) { // #pragma HLS UNROLL // gx+=gray[i+a][j+c]*Gx[c][b]; // gy+=gray[i+a][j+c]*Gy[c][b]; // } // } // } double gy =gray[i][j]+gray[i][j+1]*2+gray[i][j+2]-gray[i+2][j]-gray[i+2][j+1]*2-gray[i+2][j+2]; double gx =gray[i][j]+gray[i+1][j]*2+gray[i+2][j]-gray[i][j+2]-gray[i+1][j+2]*2-gray[i+2][j+2]; double grad = sqrt(gx*gx+gy*gy); if(grad&gt;51){ dst[i][j] = 255; } else { dst[i][j] = 0; } gx=0; gy=0; } } return; }","categories":[],"tags":[{"name":"深入理解计算机系统","slug":"深入理解计算机系统","permalink":"http://yoursite.com/tags/深入理解计算机系统/"}]},{"title":"python爬取视频","slug":"python爬取视频","date":"2019-06-17T13:34:06.000Z","updated":"2019-06-17T13:40:43.835Z","comments":true,"path":"2019/06/17/python爬取视频/","link":"","permalink":"http://yoursite.com/2019/06/17/python爬取视频/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#!/usr/bin/python# -*- coding: UTF-8 -*-import urllib,re,requestsimport sysurl_name = [] #url namedef get(): #获取源码 hd = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;&#125; url = &apos;http://www.budejie.com/video/8&apos; html = requests.get(url,headers=hd).text url_content = re.compile(r&apos;(&lt;div class=&quot;j-r-list-c&quot;&gt;.*?&lt;/div&gt;.*?&lt;/div&gt;)&apos;,re.S) #编译 url_contents = re.findall(url_content,html) #匹配 for i in url_contents: #匹配视频 url_reg = r&apos;data-mp4=&quot;(.*?)&quot;&apos; #视频地址 url_items = re.findall(url_reg,i)# print(url_items) if url_items: #判断视频是否存在 name_reg = re.compile(r&apos;&lt;a href=&quot;/detail-.&#123;8&#125;?.html&quot;&gt;(.*?)&lt;/a&gt;&apos;,re.S) name_items = re.findall(name_reg,i) #print name_items[0] for i,k in zip(name_items,url_items): url_name.append([i,k]) print(i,k) for i in url_name: #i[1]=url i[0]=name urllib.request.urlretrieve(i[1],&apos;C:\\\\Users\\\\lenovo\\\\Desktop\\\\小视频\\\\%s.mp4&apos; % (i[0])) import os,send2trashimport tqdmdir = &quot;C:\\\\Users\\\\lenovo\\\\Desktop\\\\小视频\\\\&quot; def DeleteFile(floder): dir=os.listdir(floder) for i in range(len(dir)): Size=os.path.getsize(floder+dir[i]) print(Size) if Size &gt; 3300*1024: send2trash.send2trash(floder+dir[i]) else: print(&apos;the file is normal size=%d&apos;%Size)if __name__ == &quot;__main__&quot;: #爬取视频 get() #删除特定大小的视频 DeleteFile(dir)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"git pro","slug":"git-pro","date":"2019-06-16T05:28:30.000Z","updated":"2019-06-16T05:29:12.551Z","comments":true,"path":"2019/06/16/git-pro/","link":"","permalink":"http://yoursite.com/2019/06/16/git-pro/","excerpt":"","text":"git push时出错信息 1234packet_write_wait: Connection to 13.229.188.59 port 22: Broken pipefatal: sha1 file &apos;&lt;stdout&gt;&apos; write error: Broken pipefatal: the remote end hung up unexpectedlyfatal: the remote end hung up unexpectedly 原因因为github的默认提交的文件大小是100M，如果你的文件大于100M，push时就会出现以上错误 解决修改提交时的默认文件大小：git config http.postBuffer 52428800 把大小配的大些即可！","categories":[],"tags":[{"name":"git bug","slug":"git-bug","permalink":"http://yoursite.com/tags/git-bug/"}]},{"title":"评语","slug":"评语","date":"2019-06-16T04:54:51.000Z","updated":"2019-06-16T05:32:55.311Z","comments":true,"path":"2019/06/16/评语/","link":"","permalink":"http://yoursite.com/2019/06/16/评语/","excerpt":"","text":"“课堂是老师的舞台，岂容不伦不类的人占据？是传道授业解惑的场所，岂是搔首弄姿的秀场？如此装束，如此做派，成何体统？如此荒唐的抖音主播并不罕见，想红想疯了，是不是该如其所愿，将其封了？对无底线沽取名利的炒作者，平台别失语，监管别失位。”","categories":[],"tags":[{"name":"风评","slug":"风评","permalink":"http://yoursite.com/tags/风评/"}]},{"title":"操作系统","slug":"操作系统","date":"2019-06-13T15:47:38.000Z","updated":"2019-06-13T16:30:00.002Z","comments":true,"path":"2019/06/13/操作系统/","link":"","permalink":"http://yoursite.com/2019/06/13/操作系统/","excerpt":"","text":"操作系统(1) 什么是先来先服务磁盘调度调度算法? (2) 什么是最短寻道时间优先磁盘调度算法? (3) 什么是扫描磁盘调度算法? 先来先服务磁盘调度算法: 根据进程请求访问磁盘的先后顺序进行调度 最短寻道时间: 选择距离当前磁头所在磁道最近的磁道进行访问 扫描算法: 在磁头当前移动的方向上选择与当前磁头所在磁道距离最近的磁道进行访问. 把学生和监考老师都看作进程, 学生有N人, 教师1人. 考场门口每次只能进出一个人, 进考场原则是先来先进. 当N个学生都进入考场后, 教师才能发卷子. 学生交卷后可以离开考场. 教师要等收上来全部卷子并封装卷子后才能离开考场. (1) 问共需设置几个进程? (2) 试用P、V操作解决上述问题中的同步和互斥关系. (1)n个学生进程 一个老师进程(2)设置信号量mutex= 1 12345678910111213141516171819202122232425262728293031323334in = 0out =0wait= 0student&#123; p(mutex); 进入考场; v(in); v(mutex); p(wait); 开始做卷子; 交卷; v(out); p(mutex); 离开考场; v(mutex); &#125;teacher&#123; for i to n p(in) 发卷子; for i to n v(wait); 等待学生们交卷; for i to n p(out); 封装卷子; p(mutex); 离开考场; v(mutex);&#125; 某商店有两种食品A和B, 最大数量各为m个. 该商店将A,B两种食品搭配出售, 每次各取一个. 为避免食品变质, 遵循先到食品先出售的原则, 有两个食品公司分别不断地供应A,B两种食品(每次一个). 为保证正常销售, 当某种食品的数量比另一种的数量超过k(k&lt;m)个时, 暂停对数量大的食品进货, 补充数量少的食品.(1) 问共需设置几个进程?(2) 试用P,V操作解决上述问题中的同步和互斥关系.(1) 3个进程(2)mutexA=0mutexB=0minA = kminB = k12345678910111213141516171819销售()&#123; p(mutexA); p(mutexB); 出售食品;&#125;A()&#123; p(minA) 供应A食品; v(minB) v(mutexA);&#125;B()&#123; p(minB) 供应B食品; v(minA) v(mutexA); &#125;","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"沙雕一号","slug":"沙雕一号","date":"2019-06-13T11:13:56.000Z","updated":"2019-06-13T11:19:10.118Z","comments":true,"path":"2019/06/13/沙雕一号/","link":"","permalink":"http://yoursite.com/2019/06/13/沙雕一号/","excerpt":"","text":"古早的黄磊张国荣同框合影，黄磊脸好小，哥哥竟然输了，可惜现在黄磊成了大肚腩黄小厨","categories":[],"tags":[{"name":"搞笑","slug":"搞笑","permalink":"http://yoursite.com/tags/搞笑/"}],"author":"wfs2010"}]}